//Ques 1 : (link--> https://leetcode.com/problems/count-unguarded-cells-in-the-grid/)
//         time : O(m*n) space : O(m*n) k ==> size of gaurds l ==> max of(n,m)

//Approach : Just make a 2-D array then assign 'G','W' and then 'R' then count the no of cells with 0 value
class Solution {
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        char[][] arr = new char[m][n];
        for(int[] i : walls){
            arr[i[0]][i[1]] = 'W';
        }

        for(int[] i : guards){
            arr[i[0]][i[1]] = 'G';
        }

        for(int[] i : guards){
            int j = i[1]+1;
            
            while(j < n && arr[i[0]][j] != 'W' && arr[i[0]][j] != 'G'){
                arr[i[0]][j++] = 'R';
            }
            j = i[0]+1;
            while(j < m && arr[j][i[1]] != 'W' && arr[j][i[1]] != 'G'){
                arr[j++][i[1]] = 'R';
            }
            j = i[1]-1;
            while(j >= 0 && arr[i[0]][j] != 'W' && arr[i[0]][j] != 'G'){
                arr[i[0]][j--] = 'R';
            }
            j = i[0]-1;
            while(j >= 0 && arr[j][i[1]] != 'W' && arr[j][i[1]] != 'G'){
                arr[j--][i[1]] = 'R';
            }
        }
        int count = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(arr[i][j] == 0){
                    count++;
                }
            }
        }
        return count;
    }
}

//Ques 2 : (link--> https://leetcode.com/problems/custom-sort-string/)
//         time : O(nlogn)  space : O(n)

//Approach : sort using comparators os Arrays.sort by considering priority stored in the priority HashMap to assign priorities as they come in the order array as the comparision basis
class Solution {
    public String customSortString(String order, String s) {
        Character[] c = new Character[s.length()];
        HashMap<Character, Integer> priority = new HashMap<>();
        int priorIdx = 0;
        for(int i = 0 ; i < order.length(); i++){
            char ch = order.charAt(i);
            priority.put(ch, priorIdx);
            priorIdx++;
        }
        for(int i = 0; i < s.length(); i++){
            c[i] = s.charAt(i);
            if(!priority.containsKey(s.charAt(i))){
                priority.put(s.charAt(i), -1);
            }
        }
        Arrays.sort(c, (a,b) -> priority.get(a)-priority.get(b));
        StringBuilder ans = new StringBuilder();
        for(int i = 0; i < c.length; i++){
            ans.append(c[i]);
        }
        return ans.toString();
    }
}