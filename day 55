//Ques 1 : (link--> https://leetcode.com/problems/bag-of-tokens/)
//         time : O(n) space : O(1)

//Approach : sort the array and face up the tokens until power is greater than the tokens and at last to facedown choose the maximum value token
//           in this way you can get your desired score and be aware of the edge case where tokens = [] and token.sorted[0] > power in this case there will be no score to keep at stake
class Solution {
    public int bagOfTokensScore(int[] tokens, int power) {
        Arrays.sort(tokens);
        if(tokens.length == 0 || power < tokens[0]) return 0;
        int score = 0;
        int i = 0;
        int j = tokens.length-1;
        while(i <= j){
            if(i == j && tokens[i] > power) break;
            if(tokens[i] <= power){
                score++;
                power -= tokens[i];
                i++;
            }
            else if(score >= 1){
                score--;
                power += tokens[j];
                j--;
            }  
        }
        return score;
    }
}

//Ques 2 : (link--> https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/)
//         time :O(n) space : O(n)

//Approach : just we starts from the two extreme ends then keeping the min retain store the no. of subsequence in sum then reduce the i to get the new min satisfying that nums[j]+nums[i] <= target then again add these no of subsequence in your sum but if the sum of i and j-th element increases the limit then decrease the j again repeat th esame process and get the desired answer 
//           keep the overflow out of your code
class Solution {
    public int numSubseq(int[] nums, int target) {
        Arrays.sort(nums);
        int i = 0;
        int sum = 0;
        int n = nums.length;
        int j = nums.length - 1;
        int mod = 1_000_000_007;
        int[] pow2 = new int[n];
        pow2[0] = 1;
        for (int k = 1; k < n; k++) {
            pow2[k] = (pow2[k - 1] * 2) % mod;
        }
        while (i != j) {
            if (nums[i] + nums[j] > target)
                j--;
            else {
                sum = (sum+pow2[j-i]) % mod;
                i++;
            }
        }
        if (nums[i] * 2 <= target)
            sum++;
        return (int) sum;
    }
}